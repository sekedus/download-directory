{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,I,C,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,O,O,O,C,E,Y,O,Q,O,G,E,O,W,O,C,E,C,E,C,M,C,S,C,C,C,C,C,ECAA,EAAQ,oBAA6B,QAAQ,CAAC,EAAQ,oBAAwB,YAAY,CAAC,SAAS,KAAK,KAAK,CAAC,mG,E,C,iB,Q,mB,O,E,C,Q,C,S,C,C,C,C,C,ECE/G,IAAI,EAAU,IAAI,GAgBlB,CAAA,EAAO,OAAO,CAAC,QAAQ,CAfvB,SAAkB,CAAO,CAAE,CAAQ,EACjC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAG,EAAG,GAAK,EAC5C,EAAQ,GAAG,CAAC,CAAQ,CAAC,EAAE,CAAE,CACvB,QAAS,EACT,KAAM,CAAQ,CAAC,EAAI,EAAE,AACvB,EAEJ,EASA,EAAO,OAAO,CAAC,OAAO,CARtB,SAAiB,CAAE,EACjB,IAAI,EAAW,EAAQ,GAAG,CAAC,GAC3B,GAAI,AAAY,MAAZ,EACF,MAAM,AAAI,MAAM,oCA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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/runtime-2e3a74cc4b2d4d85.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-url.js","index.ts","node_modules/typed-query-selector/shim.d.ts","node_modules/@parcel/transformer-js/src/esmodule-helpers.js","node_modules/list-github-dir-content/index.js","node_modules/p-map/index.js","download.ts","node_modules/p-retry/index.js","node_modules/retry/index.js","node_modules/retry/lib/retry.js","node_modules/retry/lib/retry_operation.js","node_modules/is-network-error/index.js","authenticated-fetch.ts","repository-info.ts","node_modules/@parcel/runtime-js/lib/runtime-5dbd7a72db21fa9a.js","node_modules/@parcel/runtime-js/lib/helpers/browser/js-loader.js","node_modules/@parcel/runtime-js/lib/helpers/cacheLoader.js"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, entry, mainEntry, parcelRequireName, globalName) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        this\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n\n      // <script>\n    } else if (globalName) {\n      this[globalName] = mainExports;\n    }\n  }\n})({\"imzaT\":[function(require,module,exports) {\nrequire(\"ea9b74cca40090cf\").register(require(\"175471d8e22905ce\").getBundleURL(\"gAkDS\"), JSON.parse('[\"gAkDS\",\"index.fe518e41.js\",\"hvOsp\",\"jszip.min.56cb75cc.js\"]'));\n\n},{\"ea9b74cca40090cf\":\"6oqja\",\"175471d8e22905ce\":\"hUXv3\"}],\"6oqja\":[function(require,module,exports) {\n\"use strict\";\nvar mapping = new Map();\nfunction register(baseUrl, manifest) {\n    for(var i = 0; i < manifest.length - 1; i += 2)mapping.set(manifest[i], {\n        baseUrl: baseUrl,\n        path: manifest[i + 1]\n    });\n}\nfunction resolve(id) {\n    var resolved = mapping.get(id);\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return new URL(resolved.path, resolved.baseUrl).toString();\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;\n\n},{}],\"hUXv3\":[function(require,module,exports) {\n\"use strict\";\nvar bundleURL = {};\nfunction getBundleURLCached(id) {\n    var value = bundleURL[id];\n    if (!value) {\n        value = getBundleURL();\n        bundleURL[id] = value;\n    }\n    return value;\n}\nfunction getBundleURL() {\n    try {\n        throw new Error();\n    } catch (err) {\n        var matches = (\"\" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^)\\n]+/g);\n        if (matches) // The first two stack frames will be this function and getBundleURLCached.\n        // Use the 3rd one, which will be a runtime in the original bundle.\n        return getBaseURL(matches[2]);\n    }\n    return \"/\";\n}\nfunction getBaseURL(url) {\n    return (\"\" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/.+)\\/[^/]+$/, \"$1\") + \"/\";\n}\n// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\nfunction getOrigin(url) {\n    var matches = (\"\" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^/]+/);\n    if (!matches) throw new Error(\"Origin not found\");\n    return matches[0];\n}\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;\n\n},{}],\"gLO4P\":[function(require,module,exports) {\n// eslint-disable-next-line import/no-unassigned-import\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nvar _typedQuerySelector = require(\"typed-query-selector\");\nvar _listGithubDirContent = require(\"list-github-dir-content\");\nvar _pMap = require(\"p-map\");\nvar _pMapDefault = parcelHelpers.interopDefault(_pMap);\nvar _downloadJs = require(\"./download.js\");\nvar _repositoryInfoJs = require(\"./repository-info.js\");\nfunction isError(error) {\n    return error instanceof Error;\n}\nfunction saveFile(blob, filename) {\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = filename;\n    a.click();\n    URL.revokeObjectURL(url);\n}\nasync function listFiles(repoListingConfig) {\n    const files = await (0, _listGithubDirContent.getDirectoryContentViaTreesApi)(repoListingConfig);\n    if (!files.truncated && files.length > 0) return files;\n    if (files.truncated) updateStatus('Warning: It\\u2019s a large repo and this it take a long while just to download the list of files. You might want to use \"git sparse checkout\" instead.');\n    return (0, _listGithubDirContent.getDirectoryContentViaContentsApi)(repoListingConfig);\n}\nfunction updateStatus(status, ...extra) {\n    const element = document.querySelector(\".status\");\n    if (status) {\n        const wrapper = document.createElement(\"div\");\n        wrapper.textContent = status;\n        element.prepend(wrapper);\n    } else element.textContent = status ?? \"\";\n    console.log(status, ...extra);\n}\nasync function getZip() {\n    // @ts-expect-error idk idc\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/consistent-type-imports\n    const JSZip = await require(\"3a6084253342d32e\");\n    return new JSZip();\n}\nfunction tokenInput() {\n    const input = document.querySelector(\"input#token\");\n    const token = localStorage.getItem(\"token\");\n    if (token) input.value = token;\n    input.addEventListener(\"input\", ()=>{\n        if (input.validity.valid) localStorage.setItem(\"token\", input.value);\n    });\n    document.querySelector(\"button#clear\").addEventListener(\"click\", ()=>{\n        input.value = \"\";\n        localStorage.removeItem(\"token\");\n    });\n}\nfunction urlInput(url, query, repofolder) {\n    const input = document.querySelector(\"input#url\");\n    input.value = url;\n    let main = (0, _repositoryInfoJs.isMainDirectory)(input.value);\n    input.addEventListener(\"input\", async ()=>{\n        main = (0, _repositoryInfoJs.isMainDirectory)(input.value);\n        if (main) repofolder.parentElement.classList.remove(\"no-items\");\n        else repofolder.parentElement.classList.add(\"no-items\");\n    });\n    if (main) {\n        if (query.has(\"without_repo_folder\")) repofolder.checked = true;\n        repofolder.parentElement.classList.remove(\"no-items\");\n    }\n}\nconst googleDoesntLikeThis = /malware|virus|trojan/i;\nasync function init() {\n    updateStatus();\n    const zipPromise = getZip();\n    const query = new URLSearchParams(location.search);\n    const url = query.get(\"url\");\n    const withoutRepoFolder = document.querySelector(\"input#repo-folder\");\n    urlInput(url ?? \"\", query, withoutRepoFolder);\n    tokenInput();\n    if (!url) return;\n    if (googleDoesntLikeThis.test(url)) {\n        updateStatus(\"Virus, malware, trojans are not allowed\");\n        return;\n    }\n    if (!navigator.onLine) {\n        updateStatus(\"\\u26A0\\uFE0F You are offline.\");\n        throw new Error(\"You are offline\");\n    }\n    const parsedPath = await (0, _repositoryInfoJs.getRepositoryInfo)(url);\n    if (\"error\" in parsedPath) {\n        // eslint-disable-next-line unicorn/prefer-switch -- I hate how it looks\n        if (parsedPath.error === \"NOT_A_REPOSITORY\") updateStatus(\"\\u26A0\\uFE0F Not a repository\");\n        else if (parsedPath.error === \"NOT_A_DIRECTORY\") updateStatus(\"\\u26A0\\uFE0F Not a directory\");\n        else if (parsedPath.error === \"REPOSITORY_NOT_FOUND\") updateStatus(\"\\u26A0\\uFE0F Repository not found. If it\\u2019s private, you should enter a token that can access it.\");\n        else updateStatus(\"\\u26A0\\uFE0F Unknown error\");\n        return;\n    }\n    const { user, repository, gitReference, directory, isPrivate } = parsedPath;\n    updateStatus(`Repo: ${user}/${repository}\\nDirectory: /${directory}`, {\n        source: {\n            user,\n            repository,\n            gitReference,\n            directory,\n            isPrivate\n        }\n    });\n    const controller = new AbortController();\n    const signal = controller.signal;\n    if (\"downloadUrl\" in parsedPath && !withoutRepoFolder.checked) {\n        updateStatus(\"Downloading the entire repository directly from GitHub\");\n        if (isPrivate) {\n            const proxy = \"https://gh-proxy.com/\";\n            const blob = await (0, _downloadJs.downloadZip)({\n                url: proxy + parsedPath.downloadUrl,\n                signal\n            });\n            saveFile(blob, `${user}-${repository}-${gitReference}.zip`);\n        } else window.location.href = parsedPath.downloadUrl;\n        return;\n    }\n    updateStatus(\"Retrieving directory info\");\n    const files = await listFiles({\n        user,\n        repository,\n        ref: gitReference,\n        directory,\n        token: localStorage.getItem(\"token\") ?? undefined,\n        getFullData: true,\n        isPrivate\n    });\n    if (files.length === 0) {\n        updateStatus(\"No files to download\");\n        return;\n    }\n    if (files.some((file)=>googleDoesntLikeThis.test(file.path))) {\n        updateStatus(\"Virus, malware, trojans are not allowed\");\n        return;\n    }\n    updateStatus(`Will download ${files.length} files`);\n    let downloaded = 0;\n    try {\n        await (0, _pMapDefault.default)(files, async (file)=>{\n            const blob = (0, _downloadJs.downloadFile)({\n                user,\n                repository,\n                reference: gitReference,\n                file,\n                isPrivate,\n                signal\n            });\n            downloaded++;\n            updateStatus(file.path);\n            const zip = await zipPromise;\n            const filePath = directory ? file.path.replace(directory + \"/\", \"\") : file.path;\n            zip.file(filePath, blob, {\n                binary: true\n            });\n        }, {\n            concurrency: 20\n        });\n    } catch (error) {\n        controller.abort();\n        if (!navigator.onLine) updateStatus(\"\\u26A0\\uFE0F Could not download all files, network connection lost.\");\n        else if (isError(error) && error.message.startsWith(\"HTTP \")) updateStatus(\"\\u26A0\\uFE0F\\uFE0F Could not download all files.\");\n        else updateStatus(\"\\u26A0\\uFE0F\\uFE0F Some files were blocked from downloading, try to disable any ad blockers and refresh the page.\");\n        throw error;\n    }\n    updateStatus(`Zipping ${downloaded} files...`);\n    const zip = await zipPromise;\n    const zipBlob = await zip.generateAsync({\n        type: \"blob\"\n    });\n    const filename = query.get(\"filename\") ?? [\n        user,\n        repository,\n        gitReference,\n        directory ? directory.replaceAll(\"/\", \"-\") : undefined\n    ].filter(Boolean).join(\"-\");\n    const zipFilename = filename.endsWith(\".zip\") ? filename : `${filename}.zip`;\n    saveFile(zipBlob, zipFilename);\n    updateStatus(`Downloaded ${downloaded} files! Done!`);\n}\n// eslint-disable-next-line unicorn/prefer-top-level-await -- Not allowed\ninit().catch((error)=>{\n    if (error instanceof Error) switch(error.message){\n        case \"Invalid token\":\n            updateStatus(\"\\u26A0\\uFE0F The token provided is invalid or has been revoked.\", {\n                token: localStorage.getItem(\"token\")\n            });\n            break;\n        case \"Rate limit exceeded\":\n            updateStatus(\"\\u26A0\\uFE0F Your token rate limit has been exceeded. Please wait or add a token\", {\n                token: localStorage.getItem(\"token\")\n            });\n            break;\n        default:\n            updateStatus(`\\u{26A0}\\u{FE0F} ${error.message}`, error);\n            break;\n    }\n});\n\n},{\"typed-query-selector\":\"hyT0C\",\"list-github-dir-content\":\"9YVya\",\"p-map\":\"iTAy0\",\"./download.js\":\"gF7Lk\",\"./repository-info.js\":\"jufXb\",\"3a6084253342d32e\":\"3dq3H\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"qayoQ\"}],\"hyT0C\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"qayoQ\"}],\"qayoQ\":[function(require,module,exports) {\nexports.interopDefault = function(a) {\n    return a && a.__esModule ? a : {\n        default: a\n    };\n};\nexports.defineInteropFlag = function(a) {\n    Object.defineProperty(a, \"__esModule\", {\n        value: true\n    });\n};\nexports.exportAll = function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n        if (key === \"default\" || key === \"__esModule\" || Object.prototype.hasOwnProperty.call(dest, key)) return;\n        Object.defineProperty(dest, key, {\n            enumerable: true,\n            get: function() {\n                return source[key];\n            }\n        });\n    });\n    return dest;\n};\nexports.export = function(dest, destName, get) {\n    Object.defineProperty(dest, destName, {\n        enumerable: true,\n        get: get\n    });\n};\n\n},{}],\"9YVya\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\n// Great for downloads with few sub directories on big repos\n// Cons: many requests if the repo has a lot of nested dirs\nparcelHelpers.export(exports, \"getDirectoryContentViaContentsApi\", ()=>getDirectoryContentViaContentsApi);\n// Great for downloads with many sub directories\n// Pros: one request + maybe doesn't require token\n// Cons: huge on huge repos + may be truncated\nparcelHelpers.export(exports, \"getDirectoryContentViaTreesApi\", ()=>getDirectoryContentViaTreesApi);\nasync function api(endpoint, token) {\n    const response = await fetch(`https://api.github.com/repos/${endpoint}`, {\n        headers: token ? {\n            Authorization: `Bearer ${token}`\n        } : undefined\n    });\n    return response.json();\n}\nasync function getDirectoryContentViaContentsApi({ user, repository, ref: reference = \"HEAD\", directory, token, getFullData = false }) {\n    const files = [];\n    const requests = [];\n    const contents = await api(`${user}/${repository}/contents/${directory}?ref=${reference}`, token);\n    if (contents.message === \"Not Found\") return [];\n    if (contents.message) throw new Error(contents.message);\n    for (const item of contents){\n        if (item.type === \"file\") files.push(getFullData ? item : item.path);\n        else if (item.type === \"dir\") requests.push(getDirectoryContentViaContentsApi({\n            user,\n            repository,\n            ref: reference,\n            directory: item.path,\n            token,\n            getFullData\n        }));\n    }\n    return [\n        ...files,\n        ...await Promise.all(requests)\n    ].flat();\n}\nasync function getDirectoryContentViaTreesApi({ user, repository, ref: reference = \"HEAD\", directory, token, getFullData = false }) {\n    if (!directory.endsWith(\"/\")) directory += \"/\";\n    const files = [];\n    const contents = await api(`${user}/${repository}/git/trees/${reference}?recursive=1`, token);\n    if (contents.message) throw new Error(contents.message);\n    for (const item of contents.tree)if (item.type === \"blob\" && item.path.startsWith(directory)) files.push(getFullData ? item : item.path);\n    files.truncated = contents.truncated;\n    return files;\n}\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"qayoQ\"}],\"iTAy0\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"default\", ()=>pMap);\nparcelHelpers.export(exports, \"pMapIterable\", ()=>pMapIterable);\nparcelHelpers.export(exports, \"pMapSkip\", ()=>pMapSkip);\nasync function pMap(iterable, mapper, { concurrency = Number.POSITIVE_INFINITY, stopOnError = true, signal } = {}) {\n    return new Promise((resolve, reject_)=>{\n        if (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) throw new TypeError(`Expected \\`input\\` to be either an \\`Iterable\\` or \\`AsyncIterable\\`, got (${typeof iterable})`);\n        if (typeof mapper !== \"function\") throw new TypeError(\"Mapper function is required\");\n        if (!(Number.isSafeInteger(concurrency) && concurrency >= 1 || concurrency === Number.POSITIVE_INFINITY)) throw new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n        const result = [];\n        const errors = [];\n        const skippedIndexesMap = new Map();\n        let isRejected = false;\n        let isResolved = false;\n        let isIterableDone = false;\n        let resolvingCount = 0;\n        let currentIndex = 0;\n        const iterator = iterable[Symbol.iterator] === undefined ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n        const reject = (reason)=>{\n            isRejected = true;\n            isResolved = true;\n            reject_(reason);\n        };\n        if (signal) {\n            if (signal.aborted) reject(signal.reason);\n            signal.addEventListener(\"abort\", ()=>{\n                reject(signal.reason);\n            });\n        }\n        const next = async ()=>{\n            if (isResolved) return;\n            const nextItem = await iterator.next();\n            const index = currentIndex;\n            currentIndex++;\n            // Note: `iterator.next()` can be called many times in parallel.\n            // This can cause multiple calls to this `next()` function to\n            // receive a `nextItem` with `done === true`.\n            // The shutdown logic that rejects/resolves must be protected\n            // so it runs only one time as the `skippedIndex` logic is\n            // non-idempotent.\n            if (nextItem.done) {\n                isIterableDone = true;\n                if (resolvingCount === 0 && !isResolved) {\n                    if (!stopOnError && errors.length > 0) {\n                        reject(new AggregateError(errors)); // eslint-disable-line unicorn/error-message\n                        return;\n                    }\n                    isResolved = true;\n                    if (skippedIndexesMap.size === 0) {\n                        resolve(result);\n                        return;\n                    }\n                    const pureResult = [];\n                    // Support multiple `pMapSkip`'s.\n                    for (const [index, value] of result.entries()){\n                        if (skippedIndexesMap.get(index) === pMapSkip) continue;\n                        pureResult.push(value);\n                    }\n                    resolve(pureResult);\n                }\n                return;\n            }\n            resolvingCount++;\n            // Intentionally detached\n            (async ()=>{\n                try {\n                    const element = await nextItem.value;\n                    if (isResolved) return;\n                    const value = await mapper(element, index);\n                    // Use Map to stage the index of the element.\n                    if (value === pMapSkip) skippedIndexesMap.set(index, value);\n                    result[index] = value;\n                    resolvingCount--;\n                    await next();\n                } catch (error) {\n                    if (stopOnError) reject(error);\n                    else {\n                        errors.push(error);\n                        resolvingCount--;\n                        // In that case we can't really continue regardless of `stopOnError` state\n                        // since an iterable is likely to continue throwing after it throws once.\n                        // If we continue calling `next()` indefinitely we will likely end up\n                        // in an infinite loop of failed iteration.\n                        try {\n                            await next();\n                        } catch (error) {\n                            reject(error);\n                        }\n                    }\n                }\n            })();\n        };\n        // Create the concurrent runners in a detached (non-awaited)\n        // promise. We need this so we can await the `next()` calls\n        // to stop creating runners before hitting the concurrency limit\n        // if the iterable has already been marked as done.\n        // NOTE: We *must* do this for async iterators otherwise we'll spin up\n        // infinite `next()` calls by default and never start the event loop.\n        (async ()=>{\n            for(let index = 0; index < concurrency; index++){\n                try {\n                    // eslint-disable-next-line no-await-in-loop\n                    await next();\n                } catch (error) {\n                    reject(error);\n                    break;\n                }\n                if (isIterableDone || isRejected) break;\n            }\n        })();\n    });\n}\nfunction pMapIterable(iterable, mapper, { concurrency = Number.POSITIVE_INFINITY, backpressure = concurrency } = {}) {\n    if (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) throw new TypeError(`Expected \\`input\\` to be either an \\`Iterable\\` or \\`AsyncIterable\\`, got (${typeof iterable})`);\n    if (typeof mapper !== \"function\") throw new TypeError(\"Mapper function is required\");\n    if (!(Number.isSafeInteger(concurrency) && concurrency >= 1 || concurrency === Number.POSITIVE_INFINITY)) throw new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n    if (!(Number.isSafeInteger(backpressure) && backpressure >= concurrency || backpressure === Number.POSITIVE_INFINITY)) throw new TypeError(`Expected \\`backpressure\\` to be an integer from \\`concurrency\\` (${concurrency}) and up or \\`Infinity\\`, got \\`${backpressure}\\` (${typeof backpressure})`);\n    return {\n        async *[Symbol.asyncIterator] () {\n            const iterator = iterable[Symbol.asyncIterator] === undefined ? iterable[Symbol.iterator]() : iterable[Symbol.asyncIterator]();\n            const promises = [];\n            let runningMappersCount = 0;\n            let isDone = false;\n            let index = 0;\n            function trySpawn() {\n                if (isDone || !(runningMappersCount < concurrency && promises.length < backpressure)) return;\n                const promise = (async ()=>{\n                    const { done, value } = await iterator.next();\n                    if (done) return {\n                        done: true\n                    };\n                    runningMappersCount++;\n                    // Spawn if still below concurrency and backpressure limit\n                    trySpawn();\n                    try {\n                        const returnValue = await mapper(await value, index++);\n                        runningMappersCount--;\n                        if (returnValue === pMapSkip) {\n                            const index = promises.indexOf(promise);\n                            if (index > 0) promises.splice(index, 1);\n                        }\n                        // Spawn if still below backpressure limit and just dropped below concurrency limit\n                        trySpawn();\n                        return {\n                            done: false,\n                            value: returnValue\n                        };\n                    } catch (error) {\n                        isDone = true;\n                        return {\n                            error\n                        };\n                    }\n                })();\n                promises.push(promise);\n            }\n            trySpawn();\n            while(promises.length > 0){\n                const { error, done, value } = await promises[0]; // eslint-disable-line no-await-in-loop\n                promises.shift();\n                if (error) throw error;\n                if (done) return;\n                // Spawn if just dropped below backpressure limit and below the concurrency limit\n                trySpawn();\n                if (value === pMapSkip) continue;\n                yield value;\n            }\n        }\n    };\n}\nconst pMapSkip = Symbol(\"skip\");\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"qayoQ\"}],\"gF7Lk\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"downloadZip\", ()=>downloadZip);\nparcelHelpers.export(exports, \"downloadFile\", ()=>downloadFile);\nvar _pRetry = require(\"p-retry\");\nvar _pRetryDefault = parcelHelpers.interopDefault(_pRetry);\nvar _authenticatedFetchJs = require(\"./authenticated-fetch.js\");\nvar _authenticatedFetchJsDefault = parcelHelpers.interopDefault(_authenticatedFetchJs);\nfunction escapeFilepath(path) {\n    return path.replaceAll(\"#\", \"%23\");\n}\nasync function maybeResponseLfs(response) {\n    const length = Number(response.headers.get(\"content-length\"));\n    if (length > 128 && length < 140) {\n        const contents = await response.clone().text();\n        return contents.startsWith(\"version https://git-lfs.github.com/spec/v1\");\n    }\n    return false;\n}\nasync function fetchPublicFile({ user, repository, reference, file, signal }) {\n    const response = await (0, _authenticatedFetchJsDefault.default)(`https://raw.githubusercontent.com/${user}/${repository}/${reference}/${escapeFilepath(file.path)}`, {\n        signal\n    });\n    if (!response.ok) throw new Error(`HTTP ${response.statusText} for ${file.path}`);\n    const lfsCompatibleResponse = await maybeResponseLfs(response) ? await (0, _authenticatedFetchJsDefault.default)(`https://media.githubusercontent.com/media/${user}/${repository}/${reference}/${escapeFilepath(file.path)}`, {\n        signal\n    }) : response;\n    if (!response.ok) throw new Error(`HTTP ${response.statusText} for ${file.path}`);\n    return lfsCompatibleResponse.blob();\n}\nasync function fetchPrivateFile({ file, signal }) {\n    const response = await (0, _authenticatedFetchJsDefault.default)(file.url, {\n        signal\n    });\n    if (!response.ok) throw new Error(`HTTP ${response.statusText} for ${file.path}`);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const { content } = await response.json();\n    const decoder = await fetch(`data:application/octet-stream;base64,${content}`);\n    return decoder.blob();\n}\nasync function downloadZip({ url, signal }) {\n    const response = await (0, _authenticatedFetchJsDefault.default)(url, {\n        signal\n    });\n    if (!response.ok) throw new Error(`HTTP ${response.statusText} for ${url}`);\n    return response.blob();\n}\nasync function downloadFile({ user, repository, reference, file, isPrivate, signal }) {\n    const token = globalThis.localStorage?.getItem(\"token\");\n    const fileRequest = {\n        user,\n        repository,\n        reference,\n        file,\n        signal\n    };\n    const localDownload = async ()=>isPrivate || token ? fetchPrivateFile(fileRequest) : fetchPublicFile(fileRequest);\n    const onFailedAttempt = (error)=>{\n        console.error(`Error downloading ${file.path}. Attempt ${error.attemptNumber}. ${error.retriesLeft} retries left.`);\n    };\n    return (0, _pRetryDefault.default)(localDownload, {\n        onFailedAttempt\n    });\n}\n\n},{\"p-retry\":\"apmLG\",\"./authenticated-fetch.js\":\"8PjCA\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"qayoQ\"}],\"apmLG\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"AbortError\", ()=>AbortError);\nparcelHelpers.export(exports, \"default\", ()=>pRetry);\nvar _retry = require(\"retry\");\nvar _retryDefault = parcelHelpers.interopDefault(_retry);\nvar _isNetworkError = require(\"is-network-error\");\nvar _isNetworkErrorDefault = parcelHelpers.interopDefault(_isNetworkError);\nclass AbortError extends Error {\n    constructor(message){\n        super();\n        if (message instanceof Error) {\n            this.originalError = message;\n            ({ message } = message);\n        } else {\n            this.originalError = new Error(message);\n            this.originalError.stack = this.stack;\n        }\n        this.name = \"AbortError\";\n        this.message = message;\n    }\n}\nconst decorateErrorWithCounts = (error, attemptNumber, options)=>{\n    // Minus 1 from attemptNumber because the first attempt does not count as a retry\n    const retriesLeft = options.retries - (attemptNumber - 1);\n    error.attemptNumber = attemptNumber;\n    error.retriesLeft = retriesLeft;\n    return error;\n};\nasync function pRetry(input, options) {\n    return new Promise((resolve, reject)=>{\n        options = {\n            onFailedAttempt () {},\n            retries: 10,\n            shouldRetry: ()=>true,\n            ...options\n        };\n        const operation = (0, _retryDefault.default).operation(options);\n        const abortHandler = ()=>{\n            operation.stop();\n            reject(options.signal?.reason);\n        };\n        if (options.signal && !options.signal.aborted) options.signal.addEventListener(\"abort\", abortHandler, {\n            once: true\n        });\n        const cleanUp = ()=>{\n            options.signal?.removeEventListener(\"abort\", abortHandler);\n            operation.stop();\n        };\n        operation.attempt(async (attemptNumber)=>{\n            try {\n                const result = await input(attemptNumber);\n                cleanUp();\n                resolve(result);\n            } catch (error) {\n                try {\n                    if (!(error instanceof Error)) throw new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`);\n                    if (error instanceof AbortError) throw error.originalError;\n                    if (error instanceof TypeError && !(0, _isNetworkErrorDefault.default)(error)) throw error;\n                    decorateErrorWithCounts(error, attemptNumber, options);\n                    if (!await options.shouldRetry(error)) {\n                        operation.stop();\n                        reject(error);\n                    }\n                    await options.onFailedAttempt(error);\n                    if (!operation.retry(error)) throw operation.mainError();\n                } catch (finalError) {\n                    decorateErrorWithCounts(finalError, attemptNumber, options);\n                    cleanUp();\n                    reject(finalError);\n                }\n            }\n        });\n    });\n}\n\n},{\"retry\":\"knQ2X\",\"is-network-error\":\"lvAqA\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"qayoQ\"}],\"knQ2X\":[function(require,module,exports) {\nmodule.exports = require(\"4f22b206be44b97e\");\n\n},{\"4f22b206be44b97e\":\"8e7jM\"}],\"8e7jM\":[function(require,module,exports) {\nvar RetryOperation = require(\"a628df618ac3d4\");\nexports.operation = function(options) {\n    var timeouts = exports.timeouts(options);\n    return new RetryOperation(timeouts, {\n        forever: options && (options.forever || options.retries === Infinity),\n        unref: options && options.unref,\n        maxRetryTime: options && options.maxRetryTime\n    });\n};\nexports.timeouts = function(options) {\n    if (options instanceof Array) return [].concat(options);\n    var opts = {\n        retries: 10,\n        factor: 2,\n        minTimeout: 1000,\n        maxTimeout: Infinity,\n        randomize: false\n    };\n    for(var key in options)opts[key] = options[key];\n    if (opts.minTimeout > opts.maxTimeout) throw new Error(\"minTimeout is greater than maxTimeout\");\n    var timeouts = [];\n    for(var i = 0; i < opts.retries; i++)timeouts.push(this.createTimeout(i, opts));\n    if (options && options.forever && !timeouts.length) timeouts.push(this.createTimeout(i, opts));\n    // sort the array numerically ascending\n    timeouts.sort(function(a, b) {\n        return a - b;\n    });\n    return timeouts;\n};\nexports.createTimeout = function(attempt, opts) {\n    var random = opts.randomize ? Math.random() + 1 : 1;\n    var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n    timeout = Math.min(timeout, opts.maxTimeout);\n    return timeout;\n};\nexports.wrap = function(obj, options, methods) {\n    if (options instanceof Array) {\n        methods = options;\n        options = null;\n    }\n    if (!methods) {\n        methods = [];\n        for(var key in obj)if (typeof obj[key] === \"function\") methods.push(key);\n    }\n    for(var i = 0; i < methods.length; i++){\n        var method = methods[i];\n        var original = obj[method];\n        obj[method] = (function retryWrapper(original) {\n            var op = exports.operation(options);\n            var args = Array.prototype.slice.call(arguments, 1);\n            var callback = args.pop();\n            args.push(function(err) {\n                if (op.retry(err)) return;\n                if (err) arguments[0] = op.mainError();\n                callback.apply(this, arguments);\n            });\n            op.attempt(function() {\n                original.apply(obj, args);\n            });\n        }).bind(obj, original);\n        obj[method].options = options;\n    }\n};\n\n},{\"a628df618ac3d4\":\"63c1u\"}],\"63c1u\":[function(require,module,exports) {\nfunction RetryOperation(timeouts, options) {\n    // Compatibility for the old (timeouts, retryForever) signature\n    if (typeof options === \"boolean\") options = {\n        forever: options\n    };\n    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n    this._timeouts = timeouts;\n    this._options = options || {};\n    this._maxRetryTime = options && options.maxRetryTime || Infinity;\n    this._fn = null;\n    this._errors = [];\n    this._attempts = 1;\n    this._operationTimeout = null;\n    this._operationTimeoutCb = null;\n    this._timeout = null;\n    this._operationStart = null;\n    this._timer = null;\n    if (this._options.forever) this._cachedTimeouts = this._timeouts.slice(0);\n}\nmodule.exports = RetryOperation;\nRetryOperation.prototype.reset = function() {\n    this._attempts = 1;\n    this._timeouts = this._originalTimeouts.slice(0);\n};\nRetryOperation.prototype.stop = function() {\n    if (this._timeout) clearTimeout(this._timeout);\n    if (this._timer) clearTimeout(this._timer);\n    this._timeouts = [];\n    this._cachedTimeouts = null;\n};\nRetryOperation.prototype.retry = function(err) {\n    if (this._timeout) clearTimeout(this._timeout);\n    if (!err) return false;\n    var currentTime = new Date().getTime();\n    if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n        this._errors.push(err);\n        this._errors.unshift(new Error(\"RetryOperation timeout occurred\"));\n        return false;\n    }\n    this._errors.push(err);\n    var timeout = this._timeouts.shift();\n    if (timeout === undefined) {\n        if (this._cachedTimeouts) {\n            // retry forever, only keep last error\n            this._errors.splice(0, this._errors.length - 1);\n            timeout = this._cachedTimeouts.slice(-1);\n        } else return false;\n    }\n    var self = this;\n    this._timer = setTimeout(function() {\n        self._attempts++;\n        if (self._operationTimeoutCb) {\n            self._timeout = setTimeout(function() {\n                self._operationTimeoutCb(self._attempts);\n            }, self._operationTimeout);\n            if (self._options.unref) self._timeout.unref();\n        }\n        self._fn(self._attempts);\n    }, timeout);\n    if (this._options.unref) this._timer.unref();\n    return true;\n};\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n    this._fn = fn;\n    if (timeoutOps) {\n        if (timeoutOps.timeout) this._operationTimeout = timeoutOps.timeout;\n        if (timeoutOps.cb) this._operationTimeoutCb = timeoutOps.cb;\n    }\n    var self = this;\n    if (this._operationTimeoutCb) this._timeout = setTimeout(function() {\n        self._operationTimeoutCb();\n    }, self._operationTimeout);\n    this._operationStart = new Date().getTime();\n    this._fn(this._attempts);\n};\nRetryOperation.prototype.try = function(fn) {\n    console.log(\"Using RetryOperation.try() is deprecated\");\n    this.attempt(fn);\n};\nRetryOperation.prototype.start = function(fn) {\n    console.log(\"Using RetryOperation.start() is deprecated\");\n    this.attempt(fn);\n};\nRetryOperation.prototype.start = RetryOperation.prototype.try;\nRetryOperation.prototype.errors = function() {\n    return this._errors;\n};\nRetryOperation.prototype.attempts = function() {\n    return this._attempts;\n};\nRetryOperation.prototype.mainError = function() {\n    if (this._errors.length === 0) return null;\n    var counts = {};\n    var mainError = null;\n    var mainErrorCount = 0;\n    for(var i = 0; i < this._errors.length; i++){\n        var error = this._errors[i];\n        var message = error.message;\n        var count = (counts[message] || 0) + 1;\n        counts[message] = count;\n        if (count >= mainErrorCount) {\n            mainError = error;\n            mainErrorCount = count;\n        }\n    }\n    return mainError;\n};\n\n},{}],\"lvAqA\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"default\", ()=>isNetworkError);\nconst objectToString = Object.prototype.toString;\nconst isError = (value)=>objectToString.call(value) === \"[object Error]\";\nconst errorMessages = new Set([\n    \"network error\",\n    \"Failed to fetch\",\n    \"NetworkError when attempting to fetch resource.\",\n    \"The Internet connection appears to be offline.\",\n    \"Load failed\",\n    \"Network request failed\",\n    \"fetch failed\",\n    \"terminated\"\n]);\nfunction isNetworkError(error) {\n    const isValid = error && isError(error) && error.name === \"TypeError\" && typeof error.message === \"string\";\n    if (!isValid) return false;\n    // We do an extra check for Safari 17+ as it has a very generic error message.\n    // Network errors in Safari have no stack.\n    if (error.message === \"Load failed\") return error.stack === undefined;\n    return errorMessages.has(error.message);\n}\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"qayoQ\"}],\"8PjCA\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"default\", ()=>authenticatedFetch);\nasync function authenticatedFetch(url, { signal, method } = {}) {\n    const token = globalThis.localStorage?.getItem(\"token\");\n    const response = await fetch(url, {\n        method,\n        signal,\n        ...token ? {\n            headers: {\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                Authorization: `Bearer ${token}`\n            }\n        } : {}\n    });\n    switch(response.status){\n        case 401:\n            throw new Error(\"Invalid token\");\n        case 403:\n        case 429:\n            // See https://developer.github.com/v3/#rate-limiting\n            if (response.headers.get(\"X-RateLimit-Remaining\") === \"0\") throw new Error(\"Rate limit exceeded\");\n            break;\n        default:\n    }\n    return response;\n}\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"qayoQ\"}],\"jufXb\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"isMainDirectory\", ()=>isMainDirectory);\nparcelHelpers.export(exports, \"getRepositoryInfo\", ()=>getRepositoryInfo);\nvar _authenticatedFetchJs = require(\"./authenticated-fetch.js\");\nvar _authenticatedFetchJsDefault = parcelHelpers.interopDefault(_authenticatedFetchJs);\nfunction cleanUrl(url) {\n    return url.replace(/[/]{2,}/, \"/\") // Drop double slashes\n    .replace(/[/]$/, \"\"); // Drop trailing slash\n}\nasync function parsePath(user, repo, parts) {\n    for(let i = 0; i < parts.length; i++){\n        const gitReference = parts.slice(0, i + 1).join(\"/\");\n        // eslint-disable-next-line no-await-in-loop -- One at a time\n        if (await checkBranchExists(user, repo, gitReference)) return {\n            gitReference,\n            directory: parts.slice(i + 1).join(\"/\")\n        };\n    }\n}\nfunction isMainDirectory(url) {\n    if (!url) return false;\n    const [, user, repository, type, ...parts] = cleanUrl(decodeURIComponent(new URL(url).pathname)).split(\"/\");\n    if (!user || !repository || type && type !== \"tree\") return false;\n    return !type || parts.length === 1;\n}\nasync function getRepositoryInfo(url) {\n    const [, user, repository, type, ...parts] = cleanUrl(decodeURIComponent(new URL(url).pathname)).split(\"/\");\n    if (!user || !repository) return {\n        error: \"NOT_A_REPOSITORY\"\n    };\n    if (type && type !== \"tree\") return {\n        error: \"NOT_A_DIRECTORY\"\n    };\n    const repoInfoResponse = await (0, _authenticatedFetchJsDefault.default)(`https://api.github.com/repos/${user}/${repository}`);\n    if (repoInfoResponse.status === 404) return {\n        error: \"REPOSITORY_NOT_FOUND\"\n    };\n    const { private: isPrivate, default_branch: gitReference } = await repoInfoResponse.json();\n    if (parts.length === 0) return {\n        user,\n        repository,\n        gitReference,\n        directory: \"\",\n        isPrivate,\n        downloadUrl: `https://api.github.com/repos/${user}/${repository}/zipball`\n    };\n    if (parts.length === 1) return {\n        user,\n        repository,\n        gitReference: parts[0],\n        directory: \"\",\n        isPrivate,\n        downloadUrl: `https://api.github.com/repos/${user}/${repository}/zipball/${parts[0]}`\n    };\n    const parsedPath = await parsePath(user, repository, parts);\n    if (!parsedPath) return {\n        error: \"BRANCH_NOT_FOUND\"\n    };\n    return {\n        user,\n        repository,\n        isPrivate,\n        ...parsedPath\n    };\n}\nasync function checkBranchExists(user, repo, gitReference) {\n    const apiUrl = `https://api.github.com/repos/${user}/${repo}/commits/${gitReference}?per_page=1`;\n    const response = await (0, _authenticatedFetchJsDefault.default)(apiUrl, {\n        method: \"HEAD\"\n    });\n    return response.ok;\n}\n\n},{\"./authenticated-fetch.js\":\"8PjCA\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"qayoQ\"}],\"3dq3H\":[function(require,module,exports) {\nmodule.exports = require(\"2fb7a8a63f385dce\")(require(\"5ff594f85ace2a66\").resolve(\"hvOsp\")).then(()=>module.bundle.root(\"eluqN\"));\n\n},{\"2fb7a8a63f385dce\":\"6i7Ox\",\"5ff594f85ace2a66\":\"6oqja\"}],\"6i7Ox\":[function(require,module,exports) {\n\"use strict\";\nvar cacheLoader = require(\"ca2a84f7fa4a3bb0\");\nmodule.exports = cacheLoader(function(bundle) {\n    return new Promise(function(resolve, reject) {\n        // Don't insert the same script twice (e.g. if it was already in the HTML)\n        var existingScripts = document.getElementsByTagName(\"script\");\n        if ([].concat(existingScripts).some(function isCurrentBundle(script) {\n            return script.src === bundle;\n        })) {\n            resolve();\n            return;\n        }\n        var preloadLink = document.createElement(\"link\");\n        preloadLink.href = bundle;\n        preloadLink.rel = \"preload\";\n        preloadLink.as = \"script\";\n        document.head.appendChild(preloadLink);\n        var script = document.createElement(\"script\");\n        script.async = true;\n        script.type = \"text/javascript\";\n        script.src = bundle;\n        script.onerror = function(e) {\n            var error = new TypeError(\"Failed to fetch dynamically imported module: \".concat(bundle, \". Error: \").concat(e.message));\n            script.onerror = script.onload = null;\n            script.remove();\n            reject(error);\n        };\n        script.onload = function() {\n            script.onerror = script.onload = null;\n            resolve();\n        };\n        document.getElementsByTagName(\"head\")[0].appendChild(script);\n    });\n});\n\n},{\"ca2a84f7fa4a3bb0\":\"jQnyX\"}],\"jQnyX\":[function(require,module,exports) {\n\"use strict\";\nvar cachedBundles = {};\nvar cachedPreloads = {};\nvar cachedPrefetches = {};\nfunction getCache(type) {\n    switch(type){\n        case \"preload\":\n            return cachedPreloads;\n        case \"prefetch\":\n            return cachedPrefetches;\n        default:\n            return cachedBundles;\n    }\n}\nmodule.exports = function(loader, type) {\n    return function(bundle) {\n        var cache = getCache(type);\n        if (cache[bundle]) return cache[bundle];\n        return cache[bundle] = loader.apply(null, arguments).catch(function(e) {\n            delete cache[bundle];\n            throw e;\n        });\n    };\n};\n\n},{}]},[\"imzaT\",\"gLO4P\"], \"gLO4P\", \"parcelRequire7d3c\")\n\n//# sourceMappingURL=index.fe518e41.js.map\n","require('./helpers/bundle-manifest').register(require('./helpers/bundle-url').getBundleURL('gAkDS'),JSON.parse(\"[\\\"gAkDS\\\",\\\"index.fe518e41.js\\\",\\\"hvOsp\\\",\\\"jszip.min.56cb75cc.js\\\"]\"));","\"use strict\";\n\nvar mapping = new Map();\nfunction register(baseUrl, manifest) {\n  for (var i = 0; i < manifest.length - 1; i += 2) {\n    mapping.set(manifest[i], {\n      baseUrl: baseUrl,\n      path: manifest[i + 1]\n    });\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping.get(id);\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return new URL(resolved.path, resolved.baseUrl).toString();\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","\"use strict\";\n\nvar bundleURL = {};\nfunction getBundleURLCached(id) {\n  var value = bundleURL[id];\n  if (!value) {\n    value = getBundleURL();\n    bundleURL[id] = value;\n  }\n  return value;\n}\nfunction getBundleURL() {\n  try {\n    throw new Error();\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^)\\n]+/g);\n    if (matches) {\n      // The first two stack frames will be this function and getBundleURLCached.\n      // Use the 3rd one, which will be a runtime in the original bundle.\n      return getBaseURL(matches[2]);\n    }\n  }\n  return '/';\n}\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n}\n\n// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\nfunction getOrigin(url) {\n  var matches = ('' + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^/]+/);\n  if (!matches) {\n    throw new Error('Origin not found');\n  }\n  return matches[0];\n}\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;","// eslint-disable-next-line import/no-unassigned-import\nimport 'typed-query-selector';\nimport {\n\tgetDirectoryContentViaContentsApi,\n\tgetDirectoryContentViaTreesApi,\n\ttype ListGithubDirectoryOptions,\n\ttype TreeResponseObject,\n\ttype ContentsReponseObject,\n} from 'list-github-dir-content';\nimport pMap from 'p-map';\nimport {downloadFile, downloadZip} from './download.js';\nimport {getRepositoryInfo, isMainDirectory} from './repository-info.js';\n\ntype ApiOptions = ListGithubDirectoryOptions & {getFullData: true; isPrivate: boolean};\n\nfunction isError(error: unknown): error is Error {\n\treturn error instanceof Error;\n}\n\nfunction saveFile(blob: Blob, filename: string) {\n\tconst url = URL.createObjectURL(blob);\n\tconst a = document.createElement('a');\n\ta.href = url;\n\ta.download = filename;\n\ta.click();\n\tURL.revokeObjectURL(url);\n}\n\nasync function listFiles(\n\trepoListingConfig: ApiOptions,\n): Promise<Array<TreeResponseObject | ContentsReponseObject>> {\n\tconst files = await getDirectoryContentViaTreesApi(repoListingConfig);\n\tif (!files.truncated && files.length > 0) {\n\t\treturn files;\n\t}\n\n\tif (files.truncated) {\n\t\tupdateStatus('Warning: It’s a large repo and this it take a long while just to download the list of files. You might want to use \"git sparse checkout\" instead.');\n\t}\n\n\treturn getDirectoryContentViaContentsApi(repoListingConfig);\n}\n\nfunction updateStatus(status?: string, ...extra: unknown[]) {\n\tconst element = document.querySelector('.status')!;\n\tif (status) {\n\t\tconst wrapper = document.createElement('div');\n\t\twrapper.textContent = status;\n\t\telement.prepend(wrapper);\n\t} else {\n\t\telement.textContent = status ?? '';\n\t}\n\n\tconsole.log(status, ...extra);\n}\n\nasync function getZip() {\n\t// @ts-expect-error idk idc\n\t// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/consistent-type-imports\n\tconst JSZip = await import('jszip') as typeof import('jszip');\n\treturn new JSZip();\n}\n\nfunction tokenInput() {\n\tconst input = document.querySelector('input#token')!;\n\tconst token = localStorage.getItem('token');\n\tif (token) {\n\t\tinput.value = token;\n\t}\n\n\tinput.addEventListener('input', () => {\n\t\tif (input.validity.valid) {\n\t\t\tlocalStorage.setItem('token', input.value);\n\t\t}\n\t});\n\n\tdocument.querySelector('button#clear')!.addEventListener('click', () => {\n\t\tinput.value = '';\n\t\tlocalStorage.removeItem('token');\n\t});\n}\n\nfunction urlInput(url: string, query: URLSearchParams, repofolder: HTMLInputElement) {\n\tconst input = document.querySelector('input#url')!;\n\tinput.value = url;\n\tlet main = isMainDirectory(input.value);\n\n\tinput.addEventListener('input', async () => {\n\t\tmain = isMainDirectory(input.value);\n\t\tif (main) {\n\t\t\trepofolder.parentElement!.classList.remove('no-items');\n\t\t} else {\n\t\t\trepofolder.parentElement!.classList.add('no-items');\n\t\t}\n\t});\n\n\tif (main) {\n\t\tif (query.has('without_repo_folder')) {\n\t\t\trepofolder.checked = true;\n\t\t}\n\n\t\trepofolder.parentElement!.classList.remove('no-items');\n\t}\n}\n\nconst googleDoesntLikeThis = /malware|virus|trojan/i;\n\nasync function init() {\n\tupdateStatus();\n\tconst zipPromise = getZip();\n\n\tconst query = new URLSearchParams(location.search);\n\tconst url = query.get('url');\n\tconst withoutRepoFolder = document.querySelector('input#repo-folder')!;\n\n\turlInput(url ?? '', query, withoutRepoFolder);\n\ttokenInput();\n\n\tif (!url) {\n\t\treturn;\n\t}\n\n\tif (googleDoesntLikeThis.test(url)) {\n\t\tupdateStatus('Virus, malware, trojans are not allowed');\n\t\treturn;\n\t}\n\n\tif (!navigator.onLine) {\n\t\tupdateStatus('⚠️ You are offline.');\n\t\tthrow new Error('You are offline');\n\t}\n\n\tconst parsedPath = await getRepositoryInfo(url);\n\n\tif ('error' in parsedPath) {\n\t\t// eslint-disable-next-line unicorn/prefer-switch -- I hate how it looks\n\t\tif (parsedPath.error === 'NOT_A_REPOSITORY') {\n\t\t\tupdateStatus('⚠️ Not a repository');\n\t\t} else if (parsedPath.error === 'NOT_A_DIRECTORY') {\n\t\t\tupdateStatus('⚠️ Not a directory');\n\t\t} else if (parsedPath.error === 'REPOSITORY_NOT_FOUND') {\n\t\t\tupdateStatus('⚠️ Repository not found. If it’s private, you should enter a token that can access it.');\n\t\t} else {\n\t\t\tupdateStatus('⚠️ Unknown error');\n\t\t}\n\n\t\treturn;\n\t}\n\n\tconst {user, repository, gitReference, directory, isPrivate} = parsedPath;\n\tupdateStatus(`Repo: ${user}/${repository}\\nDirectory: /${directory}`, {\n\t\tsource: {\n\t\t\tuser,\n\t\t\trepository,\n\t\t\tgitReference,\n\t\t\tdirectory,\n\t\t\tisPrivate,\n\t\t},\n\t});\n\n\tconst controller = new AbortController();\n\tconst signal = controller.signal;\n\n\tif ('downloadUrl' in parsedPath && !withoutRepoFolder.checked) {\n\t\tupdateStatus('Downloading the entire repository directly from GitHub');\n\t\tif (isPrivate) {\n\t\t\tconst proxy = 'https://gh-proxy.com/';\n\t\t\tconst blob = await downloadZip({\n\t\t\t\turl: proxy + parsedPath.downloadUrl,\n\t\t\t\tsignal,\n\t\t\t});\n\t\t\tsaveFile(blob, `${user}-${repository}-${gitReference}.zip`);\n\t\t} else {\n\t\t\twindow.location.href = parsedPath.downloadUrl;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tupdateStatus('Retrieving directory info');\n\n\tconst files = await listFiles({\n\t\tuser,\n\t\trepository,\n\t\tref: gitReference,\n\t\tdirectory,\n\t\ttoken: localStorage.getItem('token') ?? undefined,\n\t\tgetFullData: true,\n\t\tisPrivate,\n\t});\n\n\tif (files.length === 0) {\n\t\tupdateStatus('No files to download');\n\t\treturn;\n\t}\n\n\tif (files.some(file => googleDoesntLikeThis.test(file.path))) {\n\t\tupdateStatus('Virus, malware, trojans are not allowed');\n\t\treturn;\n\t}\n\n\tupdateStatus(`Will download ${files.length} files`);\n\n\tlet downloaded = 0;\n\n\ttry {\n\t\tawait pMap(files, async file => {\n\t\t\tconst blob = downloadFile({\n\t\t\t\tuser,\n\t\t\t\trepository,\n\t\t\t\treference: gitReference!,\n\t\t\t\tfile,\n\t\t\t\tisPrivate,\n\t\t\t\tsignal,\n\t\t\t});\n\n\t\t\tdownloaded++;\n\t\t\tupdateStatus(file.path);\n\n\t\t\tconst zip = await zipPromise;\n\t\t\tconst filePath = directory ? file.path.replace(directory + '/', '') : file.path;\n\t\t\tzip.file(filePath, blob, {\n\t\t\t\tbinary: true,\n\t\t\t});\n\t\t}, {concurrency: 20});\n\t} catch (error) {\n\t\tcontroller.abort();\n\n\t\tif (!navigator.onLine) {\n\t\t\tupdateStatus('⚠️ Could not download all files, network connection lost.');\n\t\t} else if (isError(error) && error.message.startsWith('HTTP ')) {\n\t\t\tupdateStatus('⚠️️ Could not download all files.');\n\t\t} else {\n\t\t\tupdateStatus(\n\t\t\t\t'⚠️️ Some files were blocked from downloading, try to disable any ad blockers and refresh the page.',\n\t\t\t);\n\t\t}\n\n\t\tthrow error;\n\t}\n\n\tupdateStatus(`Zipping ${downloaded} files...`);\n\n\tconst zip = await zipPromise;\n\tconst zipBlob = await zip.generateAsync({\n\t\ttype: 'blob',\n\t});\n\n\tconst filename = query.get('filename')\n\t\t?? [\n\t\t\tuser,\n\t\t\trepository,\n\t\t\tgitReference,\n\t\t\tdirectory ? directory.replaceAll('/', '-') : undefined,\n\t\t].filter(Boolean).join('-');\n\n\tconst zipFilename = filename.endsWith('.zip') ? filename : `${filename}.zip`;\n\tsaveFile(zipBlob, zipFilename);\n\tupdateStatus(`Downloaded ${downloaded} files! Done!`);\n}\n\n// eslint-disable-next-line unicorn/prefer-top-level-await -- Not allowed\nvoid init().catch(error => {\n\tif (error instanceof Error) {\n\t\tswitch (error.message) {\n\t\t\tcase 'Invalid token': {\n\t\t\t\tupdateStatus('⚠️ The token provided is invalid or has been revoked.', {\n\t\t\t\t\ttoken: localStorage.getItem('token'),\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase 'Rate limit exceeded': {\n\t\t\t\tupdateStatus(\n\t\t\t\t\t'⚠️ Your token rate limit has been exceeded. Please wait or add a token',\n\t\t\t\t\t{token: localStorage.getItem('token')},\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tupdateStatus(`⚠️ ${error.message}`, error);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n});\n","import type { ParseSelector } from './parser.js'\n\ndeclare global {\n  interface ParentNode {\n    querySelector<S extends string>(selector: S): ParseSelector<S> | null\n\n    querySelectorAll<S extends string>(\n      selector: S,\n    ): NodeListOf<ParseSelector<S>>\n  }\n\n  interface Element {\n    closest<S extends string>(selector: S): ParseSelector<S> | null\n  }\n}\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n","async function api(endpoint, token) {\n\tconst response = await fetch(`https://api.github.com/repos/${endpoint}`, {\n\t\theaders: token ? {\n\t\t\tAuthorization: `Bearer ${token}`,\n\t\t} : undefined,\n\t});\n\treturn response.json();\n}\n\n// Great for downloads with few sub directories on big repos\n// Cons: many requests if the repo has a lot of nested dirs\nexport async function getDirectoryContentViaContentsApi({\n\tuser,\n\trepository,\n\tref: reference = 'HEAD',\n\tdirectory,\n\ttoken,\n\tgetFullData = false,\n}) {\n\tconst files = [];\n\tconst requests = [];\n\tconst contents = await api(`${user}/${repository}/contents/${directory}?ref=${reference}`, token);\n\n\tif (contents.message === 'Not Found') {\n\t\treturn [];\n\t}\n\n\tif (contents.message) {\n\t\tthrow new Error(contents.message);\n\t}\n\n\tfor (const item of contents) {\n\t\tif (item.type === 'file') {\n\t\t\tfiles.push(getFullData ? item : item.path);\n\t\t} else if (item.type === 'dir') {\n\t\t\trequests.push(getDirectoryContentViaContentsApi({\n\t\t\t\tuser,\n\t\t\t\trepository,\n\t\t\t\tref: reference,\n\t\t\t\tdirectory: item.path,\n\t\t\t\ttoken,\n\t\t\t\tgetFullData,\n\t\t\t}));\n\t\t}\n\t}\n\n\treturn [...files, ...await Promise.all(requests)].flat();\n}\n\n// Great for downloads with many sub directories\n// Pros: one request + maybe doesn't require token\n// Cons: huge on huge repos + may be truncated\nexport async function getDirectoryContentViaTreesApi({\n\tuser,\n\trepository,\n\tref: reference = 'HEAD',\n\tdirectory,\n\ttoken,\n\tgetFullData = false,\n}) {\n\tif (!directory.endsWith('/')) {\n\t\tdirectory += '/';\n\t}\n\n\tconst files = [];\n\tconst contents = await api(`${user}/${repository}/git/trees/${reference}?recursive=1`, token);\n\tif (contents.message) {\n\t\tthrow new Error(contents.message);\n\t}\n\n\tfor (const item of contents.tree) {\n\t\tif (item.type === 'blob' && item.path.startsWith(directory)) {\n\t\t\tfiles.push(getFullData ? item : item.path);\n\t\t}\n\t}\n\n\tfiles.truncated = contents.truncated;\n\treturn files;\n}\n","export default async function pMap(\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Number.POSITIVE_INFINITY,\n\t\tstopOnError = true,\n\t\tsignal,\n\t} = {},\n) {\n\treturn new Promise((resolve, reject_) => {\n\t\tif (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {\n\t\t\tthrow new TypeError(`Expected \\`input\\` to be either an \\`Iterable\\` or \\`AsyncIterable\\`, got (${typeof iterable})`);\n\t\t}\n\n\t\tif (typeof mapper !== 'function') {\n\t\t\tthrow new TypeError('Mapper function is required');\n\t\t}\n\n\t\tif (!((Number.isSafeInteger(concurrency) && concurrency >= 1) || concurrency === Number.POSITIVE_INFINITY)) {\n\t\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t\t}\n\n\t\tconst result = [];\n\t\tconst errors = [];\n\t\tconst skippedIndexesMap = new Map();\n\t\tlet isRejected = false;\n\t\tlet isResolved = false;\n\t\tlet isIterableDone = false;\n\t\tlet resolvingCount = 0;\n\t\tlet currentIndex = 0;\n\t\tconst iterator = iterable[Symbol.iterator] === undefined ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n\n\t\tconst reject = reason => {\n\t\t\tisRejected = true;\n\t\t\tisResolved = true;\n\t\t\treject_(reason);\n\t\t};\n\n\t\tif (signal) {\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(signal.reason);\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\treject(signal.reason);\n\t\t\t});\n\t\t}\n\n\t\tconst next = async () => {\n\t\t\tif (isResolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextItem = await iterator.next();\n\n\t\t\tconst index = currentIndex;\n\t\t\tcurrentIndex++;\n\n\t\t\t// Note: `iterator.next()` can be called many times in parallel.\n\t\t\t// This can cause multiple calls to this `next()` function to\n\t\t\t// receive a `nextItem` with `done === true`.\n\t\t\t// The shutdown logic that rejects/resolves must be protected\n\t\t\t// so it runs only one time as the `skippedIndex` logic is\n\t\t\t// non-idempotent.\n\t\t\tif (nextItem.done) {\n\t\t\t\tisIterableDone = true;\n\n\t\t\t\tif (resolvingCount === 0 && !isResolved) {\n\t\t\t\t\tif (!stopOnError && errors.length > 0) {\n\t\t\t\t\t\treject(new AggregateError(errors)); // eslint-disable-line unicorn/error-message\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tisResolved = true;\n\n\t\t\t\t\tif (skippedIndexesMap.size === 0) {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst pureResult = [];\n\n\t\t\t\t\t// Support multiple `pMapSkip`'s.\n\t\t\t\t\tfor (const [index, value] of result.entries()) {\n\t\t\t\t\t\tif (skippedIndexesMap.get(index) === pMapSkip) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpureResult.push(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(pureResult);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolvingCount++;\n\n\t\t\t// Intentionally detached\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst element = await nextItem.value;\n\n\t\t\t\t\tif (isResolved) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = await mapper(element, index);\n\n\t\t\t\t\t// Use Map to stage the index of the element.\n\t\t\t\t\tif (value === pMapSkip) {\n\t\t\t\t\t\tskippedIndexesMap.set(index, value);\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[index] = value;\n\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tawait next();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (stopOnError) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors.push(error);\n\t\t\t\t\t\tresolvingCount--;\n\n\t\t\t\t\t\t// In that case we can't really continue regardless of `stopOnError` state\n\t\t\t\t\t\t// since an iterable is likely to continue throwing after it throws once.\n\t\t\t\t\t\t// If we continue calling `next()` indefinitely we will likely end up\n\t\t\t\t\t\t// in an infinite loop of failed iteration.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait next();\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t};\n\n\t\t// Create the concurrent runners in a detached (non-awaited)\n\t\t// promise. We need this so we can await the `next()` calls\n\t\t// to stop creating runners before hitting the concurrency limit\n\t\t// if the iterable has already been marked as done.\n\t\t// NOTE: We *must* do this for async iterators otherwise we'll spin up\n\t\t// infinite `next()` calls by default and never start the event loop.\n\t\t(async () => {\n\t\t\tfor (let index = 0; index < concurrency; index++) {\n\t\t\t\ttry {\n\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\tawait next();\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isIterableDone || isRejected) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\t});\n}\n\nexport function pMapIterable(\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Number.POSITIVE_INFINITY,\n\t\tbackpressure = concurrency,\n\t} = {},\n) {\n\tif (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {\n\t\tthrow new TypeError(`Expected \\`input\\` to be either an \\`Iterable\\` or \\`AsyncIterable\\`, got (${typeof iterable})`);\n\t}\n\n\tif (typeof mapper !== 'function') {\n\t\tthrow new TypeError('Mapper function is required');\n\t}\n\n\tif (!((Number.isSafeInteger(concurrency) && concurrency >= 1) || concurrency === Number.POSITIVE_INFINITY)) {\n\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t}\n\n\tif (!((Number.isSafeInteger(backpressure) && backpressure >= concurrency) || backpressure === Number.POSITIVE_INFINITY)) {\n\t\tthrow new TypeError(`Expected \\`backpressure\\` to be an integer from \\`concurrency\\` (${concurrency}) and up or \\`Infinity\\`, got \\`${backpressure}\\` (${typeof backpressure})`);\n\t}\n\n\treturn {\n\t\tasync * [Symbol.asyncIterator]() {\n\t\t\tconst iterator = iterable[Symbol.asyncIterator] === undefined ? iterable[Symbol.iterator]() : iterable[Symbol.asyncIterator]();\n\n\t\t\tconst promises = [];\n\t\t\tlet runningMappersCount = 0;\n\t\t\tlet isDone = false;\n\t\t\tlet index = 0;\n\n\t\t\tfunction trySpawn() {\n\t\t\t\tif (isDone || !(runningMappersCount < concurrency && promises.length < backpressure)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst promise = (async () => {\n\t\t\t\t\tconst {done, value} = await iterator.next();\n\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\treturn {done: true};\n\t\t\t\t\t}\n\n\t\t\t\t\trunningMappersCount++;\n\n\t\t\t\t\t// Spawn if still below concurrency and backpressure limit\n\t\t\t\t\ttrySpawn();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst returnValue = await mapper(await value, index++);\n\n\t\t\t\t\t\trunningMappersCount--;\n\n\t\t\t\t\t\tif (returnValue === pMapSkip) {\n\t\t\t\t\t\t\tconst index = promises.indexOf(promise);\n\n\t\t\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\t\t\tpromises.splice(index, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Spawn if still below backpressure limit and just dropped below concurrency limit\n\t\t\t\t\t\ttrySpawn();\n\n\t\t\t\t\t\treturn {done: false, value: returnValue};\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tisDone = true;\n\t\t\t\t\t\treturn {error};\n\t\t\t\t\t}\n\t\t\t\t})();\n\n\t\t\t\tpromises.push(promise);\n\t\t\t}\n\n\t\t\ttrySpawn();\n\n\t\t\twhile (promises.length > 0) {\n\t\t\t\tconst {error, done, value} = await promises[0]; // eslint-disable-line no-await-in-loop\n\n\t\t\t\tpromises.shift();\n\n\t\t\t\tif (error) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\tif (done) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Spawn if just dropped below backpressure limit and below the concurrency limit\n\t\t\t\ttrySpawn();\n\n\t\t\t\tif (value === pMapSkip) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tyield value;\n\t\t\t}\n\t\t},\n\t};\n}\n\nexport const pMapSkip = Symbol('skip');\n","import {type ContentsReponseObject, type TreeResponseObject} from 'list-github-dir-content';\nimport pRetry, {type FailedAttemptError} from 'p-retry';\nimport authenticatedFetch from './authenticated-fetch.js';\n\nfunction escapeFilepath(path: string) {\n\treturn path.replaceAll('#', '%23');\n}\n\nasync function maybeResponseLfs(response: Response): Promise<boolean> {\n\tconst length = Number(response.headers.get('content-length'));\n\tif (length > 128 && length < 140) {\n\t\tconst contents = await response.clone().text();\n\t\treturn contents.startsWith('version https://git-lfs.github.com/spec/v1');\n\t}\n\n\treturn false;\n}\n\ntype FileRequest = {\n\tuser: string;\n\trepository: string;\n\treference: string;\n\tfile: TreeResponseObject | ContentsReponseObject;\n\tsignal: AbortSignal;\n};\n\nasync function fetchPublicFile({\n\tuser,\n\trepository,\n\treference,\n\tfile,\n\tsignal,\n}: FileRequest) {\n\tconst response = await authenticatedFetch(\n\t\t`https://raw.githubusercontent.com/${user}/${repository}/${reference}/${escapeFilepath(file.path)}`,\n\t\t{signal},\n\t);\n\n\tif (!response.ok) {\n\t\tthrow new Error(`HTTP ${response.statusText} for ${file.path}`);\n\t}\n\n\tconst lfsCompatibleResponse = (await maybeResponseLfs(response))\n\t\t? await authenticatedFetch(\n\t\t\t`https://media.githubusercontent.com/media/${user}/${repository}/${reference}/${escapeFilepath(file.path)}`,\n\t\t\t{signal},\n\t\t)\n\t\t: response;\n\n\tif (!response.ok) {\n\t\tthrow new Error(`HTTP ${response.statusText} for ${file.path}`);\n\t}\n\n\treturn lfsCompatibleResponse.blob();\n}\n\nasync function fetchPrivateFile({\n\tfile,\n\tsignal,\n}: FileRequest) {\n\tconst response = await authenticatedFetch(file.url, {signal});\n\n\tif (!response.ok) {\n\t\tthrow new Error(`HTTP ${response.statusText} for ${file.path}`);\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\tconst {content} = await response.json();\n\tconst decoder = await fetch(\n\t\t`data:application/octet-stream;base64,${content}`,\n\t);\n\treturn decoder.blob();\n}\n\nexport async function downloadZip({\n\turl,\n\tsignal,\n}: {\n\turl: string;\n\tsignal: AbortSignal;\n}) {\n\tconst response = await authenticatedFetch(url, {signal});\n\n\tif (!response.ok) {\n\t\tthrow new Error(`HTTP ${response.statusText} for ${url}`);\n\t}\n\n\treturn response.blob();\n}\n\nexport async function downloadFile({\n\tuser,\n\trepository,\n\treference,\n\tfile,\n\tisPrivate,\n\tsignal,\n}: {\n\tuser: string;\n\trepository: string;\n\treference: string;\n\tisPrivate: boolean;\n\tfile: TreeResponseObject | ContentsReponseObject;\n\tsignal: AbortSignal;\n}) {\n\tconst token = globalThis.localStorage?.getItem('token');\n\tconst fileRequest = {\n\t\tuser, repository, reference, file, signal,\n\t};\n\tconst localDownload = async () =>\n\t\tisPrivate || token\n\t\t\t? fetchPrivateFile(fileRequest)\n\t\t\t: fetchPublicFile(fileRequest);\n\tconst onFailedAttempt = (error: FailedAttemptError) => {\n\t\tconsole.error(\n\t\t\t`Error downloading ${file.path}. Attempt ${error.attemptNumber}. ${error.retriesLeft} retries left.`,\n\t\t);\n\t};\n\n\treturn pRetry(localDownload, {onFailedAttempt});\n}\n","import retry from 'retry';\nimport isNetworkError from 'is-network-error';\n\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nconst decorateErrorWithCounts = (error, attemptNumber, options) => {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\terror.attemptNumber = attemptNumber;\n\terror.retriesLeft = retriesLeft;\n\treturn error;\n};\n\nexport default async function pRetry(input, options) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = {\n\t\t\tonFailedAttempt() {},\n\t\t\tretries: 10,\n\t\t\tshouldRetry: () => true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst operation = retry.operation(options);\n\n\t\tconst abortHandler = () => {\n\t\t\toperation.stop();\n\t\t\treject(options.signal?.reason);\n\t\t};\n\n\t\tif (options.signal && !options.signal.aborted) {\n\t\t\toptions.signal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tconst cleanUp = () => {\n\t\t\toptions.signal?.removeEventListener('abort', abortHandler);\n\t\t\toperation.stop();\n\t\t};\n\n\t\toperation.attempt(async attemptNumber => {\n\t\t\ttry {\n\t\t\t\tconst result = await input(attemptNumber);\n\t\t\t\tcleanUp();\n\t\t\t\tresolve(result);\n\t\t\t} catch (error) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!(error instanceof Error)) {\n\t\t\t\t\t\tthrow new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof AbortError) {\n\t\t\t\t\t\tthrow error.originalError;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof TypeError && !isNetworkError(error)) {\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\n\t\t\t\t\tif (!(await options.shouldRetry(error))) {\n\t\t\t\t\t\toperation.stop();\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tawait options.onFailedAttempt(error);\n\n\t\t\t\t\tif (!operation.retry(error)) {\n\t\t\t\t\t\tthrow operation.mainError();\n\t\t\t\t\t}\n\t\t\t\t} catch (finalError) {\n\t\t\t\t\tdecorateErrorWithCounts(finalError, attemptNumber, options);\n\t\t\t\t\tcleanUp();\n\t\t\t\t\treject(finalError);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n","module.exports = require('./lib/retry');","var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n","function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n","const objectToString = Object.prototype.toString;\n\nconst isError = value => objectToString.call(value) === '[object Error]';\n\nconst errorMessages = new Set([\n\t'network error', // Chrome\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari 16\n\t'Load failed', // Safari 17+\n\t'Network request failed', // `cross-fetch`\n\t'fetch failed', // Undici (Node.js)\n\t'terminated', // Undici (Node.js)\n]);\n\nexport default function isNetworkError(error) {\n\tconst isValid = error\n\t\t&& isError(error)\n\t\t&& error.name === 'TypeError'\n\t\t&& typeof error.message === 'string';\n\n\tif (!isValid) {\n\t\treturn false;\n\t}\n\n\t// We do an extra check for Safari 17+ as it has a very generic error message.\n\t// Network errors in Safari have no stack.\n\tif (error.message === 'Load failed') {\n\t\treturn error.stack === undefined;\n\t}\n\n\treturn errorMessages.has(error.message);\n}\n","export default async function authenticatedFetch(\n\turl: string,\n\t{signal, method}: {signal?: AbortSignal; method?: 'HEAD'} = {},\n): Promise<Response> {\n\tconst token = globalThis.localStorage?.getItem('token');\n\n\tconst response = await fetch(url, {\n\t\tmethod,\n\t\tsignal,\n\t\t...(token\n\t\t\t? {\n\t\t\t\theaders: {\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/naming-convention\n\t\t\t\t\tAuthorization: `Bearer ${token}`,\n\t\t\t\t},\n\t\t\t}\n\t\t\t: {}),\n\t});\n\n\tswitch (response.status) {\n\t\tcase 401: {\n\t\t\tthrow new Error('Invalid token');\n\t\t}\n\n\t\tcase 403:\n\t\tcase 429: {\n\t\t\t// See https://developer.github.com/v3/#rate-limiting\n\t\t\tif (response.headers.get('X-RateLimit-Remaining') === '0') {\n\t\t\t\tthrow new Error('Rate limit exceeded');\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t}\n\n\treturn response;\n}\n","import authenticatedFetch from './authenticated-fetch.js';\n\nfunction cleanUrl(url: string) {\n\treturn url\n\t\t.replace(/[/]{2,}/, '/') // Drop double slashes\n\t\t.replace(/[/]$/, ''); // Drop trailing slash\n}\n\nasync function parsePath(\n\tuser: string,\n\trepo: string,\n\tparts: string[],\n): Promise<{gitReference: string; directory: string} | void> {\n\tfor (let i = 0; i < parts.length; i++) {\n\t\tconst gitReference = parts.slice(0, i + 1).join('/');\n\t\t// eslint-disable-next-line no-await-in-loop -- One at a time\n\t\tif (await checkBranchExists(user, repo, gitReference)) {\n\t\t\treturn {\n\t\t\t\tgitReference,\n\t\t\t\tdirectory: parts.slice(i + 1).join('/'),\n\t\t\t};\n\t\t}\n\t}\n}\n\nexport function isMainDirectory(url: string) {\n\tif (!url) {\n\t\treturn false;\n\t}\n\n\tconst [, user, repository, type, ...parts] = cleanUrl(\n\t\tdecodeURIComponent(new URL(url).pathname),\n\t).split('/');\n\n\tif ((!user || !repository) || (type && type !== 'tree')) {\n\t\treturn false;\n\t}\n\n\treturn !type || parts.length === 1;\n}\n\nexport async function getRepositoryInfo(\n\turl: string,\n): Promise<\n\t| {error: string}\n\t| {\n\t\tuser: string;\n\t\trepository: string;\n\t\tgitReference?: string;\n\t\tdirectory: string;\n\t\tdownloadUrl: string;\n\t\tisPrivate: boolean;\n\t}\n\t| {\n\t\tuser: string;\n\t\trepository: string;\n\t\tgitReference: string;\n\t\tdirectory: string;\n\t\tisPrivate: boolean;\n\t}\n\t> {\n\tconst [, user, repository, type, ...parts] = cleanUrl(\n\t\tdecodeURIComponent(new URL(url).pathname),\n\t).split('/');\n\n\tif (!user || !repository) {\n\t\treturn {error: 'NOT_A_REPOSITORY'};\n\t}\n\n\tif (type && type !== 'tree') {\n\t\treturn {error: 'NOT_A_DIRECTORY'};\n\t}\n\n\tconst repoInfoResponse = await authenticatedFetch(\n\t\t`https://api.github.com/repos/${user}/${repository}`,\n\t);\n\n\tif (repoInfoResponse.status === 404) {\n\t\treturn {error: 'REPOSITORY_NOT_FOUND'};\n\t}\n\n\tconst {private: isPrivate, default_branch: gitReference} = await repoInfoResponse.json() as {\n\t\tprivate: boolean;\n\t\tdefault_branch: string;\n\t};\n\n\tif (parts.length === 0) {\n\t\treturn {\n\t\t\tuser,\n\t\t\trepository,\n\t\t\tgitReference,\n\t\t\tdirectory: '',\n\t\t\tisPrivate,\n\t\t\tdownloadUrl: `https://api.github.com/repos/${user}/${repository}/zipball`,\n\t\t};\n\t}\n\n\tif (parts.length === 1) {\n\t\treturn {\n\t\t\tuser,\n\t\t\trepository,\n\t\t\tgitReference: parts[0],\n\t\t\tdirectory: '',\n\t\t\tisPrivate,\n\t\t\tdownloadUrl: `https://api.github.com/repos/${user}/${repository}/zipball/${parts[0]}`,\n\t\t};\n\t}\n\n\tconst parsedPath = await parsePath(user, repository, parts);\n\tif (!parsedPath) {\n\t\treturn {error: 'BRANCH_NOT_FOUND'};\n\t}\n\n\treturn {\n\t\tuser,\n\t\trepository,\n\t\tisPrivate,\n\t\t...parsedPath,\n\t};\n}\n\nasync function checkBranchExists(user: string, repo: string, gitReference: string): Promise<boolean> {\n\tconst apiUrl = `https://api.github.com/repos/${user}/${repo}/commits/${gitReference}?per_page=1`;\n\tconst response = await authenticatedFetch(apiUrl, {method: 'HEAD'});\n\treturn response.ok;\n}\n","module.exports = (require(\"./helpers/browser/js-loader\")(require('./helpers/bundle-manifest').resolve(\"hvOsp\"))).then(() => module.bundle.root('eluqN'));","\"use strict\";\n\nvar cacheLoader = require('../cacheLoader');\nmodule.exports = cacheLoader(function (bundle) {\n  return new Promise(function (resolve, reject) {\n    // Don't insert the same script twice (e.g. if it was already in the HTML)\n    var existingScripts = document.getElementsByTagName('script');\n    if ([].concat(existingScripts).some(function isCurrentBundle(script) {\n      return script.src === bundle;\n    })) {\n      resolve();\n      return;\n    }\n    var preloadLink = document.createElement('link');\n    preloadLink.href = bundle;\n    preloadLink.rel = 'preload';\n    preloadLink.as = 'script';\n    document.head.appendChild(preloadLink);\n    var script = document.createElement('script');\n    script.async = true;\n    script.type = 'text/javascript';\n    script.src = bundle;\n    script.onerror = function (e) {\n      var error = new TypeError(\"Failed to fetch dynamically imported module: \".concat(bundle, \". Error: \").concat(e.message));\n      script.onerror = script.onload = null;\n      script.remove();\n      reject(error);\n    };\n    script.onload = function () {\n      script.onerror = script.onload = null;\n      resolve();\n    };\n    document.getElementsByTagName('head')[0].appendChild(script);\n  });\n});","\"use strict\";\n\nvar cachedBundles = {};\nvar cachedPreloads = {};\nvar cachedPrefetches = {};\nfunction getCache(type) {\n  switch (type) {\n    case 'preload':\n      return cachedPreloads;\n    case 'prefetch':\n      return cachedPrefetches;\n    default:\n      return cachedBundles;\n  }\n}\nmodule.exports = function (loader, type) {\n  return function (bundle) {\n    var cache = getCache(type);\n    if (cache[bundle]) {\n      return cache[bundle];\n    }\n    return cache[bundle] = loader.apply(null, arguments).catch(function (e) {\n      delete cache[bundle];\n      throw e;\n    });\n  };\n};"],"names":["modules","entry","mainEntry","parcelRequireName","globalName","globalObject","globalThis","self","window","global","previousRequire","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","i","length","mainExports","define","amd","getBundleURL","JSON","parse","mapping","Map","baseUrl","manifest","set","path","resolved","URL","toString","bundleURL","getBaseURL","url","replace","value","matches","stack","match","getOrigin","parcelHelpers","_listGithubDirContent","_pMap","_pMapDefault","interopDefault","_downloadJs","_repositoryInfoJs","saveFile","blob","filename","createObjectURL","a","document","createElement","href","download","click","revokeObjectURL","listFiles","repoListingConfig","files","getDirectoryContentViaTreesApi","truncated","updateStatus","getDirectoryContentViaContentsApi","status","extra","element","querySelector","wrapper","textContent","prepend","console","log","getZip","googleDoesntLikeThis","init","zipPromise","query","URLSearchParams","location","search","withoutRepoFolder","urlInput","repofolder","input","main","isMainDirectory","addEventListener","parentElement","classList","remove","add","has","checked","tokenInput","token","localStorage","getItem","validity","valid","setItem","removeItem","test","navigator","onLine","parsedPath","getRepositoryInfo","error","user","repository","gitReference","directory","isPrivate","source","controller","AbortController","signal","downloadZip","proxy","downloadUrl","ref","undefined","getFullData","some","file","downloaded","default","downloadFile","reference","zip","filePath","binary","concurrency","abort","isError","message","startsWith","zipBlob","generateAsync","type","replaceAll","filter","Boolean","join","endsWith","catch","defineInteropFlag","__esModule","exportAll","dest","keys","forEach","key","prototype","hasOwnProperty","enumerable","export","destName","api","endpoint","response","fetch","headers","Authorization","json","requests","contents","item","push","Promise","all","flat","tree","pMap","iterable","mapper","Number","POSITIVE_INFINITY","stopOnError","reject_","Symbol","iterator","asyncIterator","TypeError","isSafeInteger","result","errors","skippedIndexesMap","isRejected","isResolved","isIterableDone","resolvingCount","currentIndex","reject","reason","aborted","next","nextItem","index","done","AggregateError","size","pureResult","entries","pMapSkip","pMapIterable","backpressure","promises","runningMappersCount","isDone","trySpawn","promise","returnValue","indexOf","splice","shift","_pRetry","_pRetryDefault","_authenticatedFetchJs","_authenticatedFetchJsDefault","escapeFilepath","maybeResponseLfs","clone","text","fetchPublicFile","ok","statusText","lfsCompatibleResponse","fetchPrivateFile","content","decoder","fileRequest","localDownload","onFailedAttempt","attemptNumber","retriesLeft","AbortError","pRetry","_retry","_retryDefault","_isNetworkError","_isNetworkErrorDefault","constructor","originalError","decorateErrorWithCounts","options","retries","shouldRetry","operation","abortHandler","stop","once","cleanUp","removeEventListener","attempt","retry","mainError","finalError","RetryOperation","timeouts","forever","Infinity","unref","maxRetryTime","Array","concat","opts","factor","minTimeout","maxTimeout","randomize","createTimeout","sort","b","Math","min","round","random","max","pow","wrap","obj","methods","method","original","op","args","slice","arguments","callback","pop","apply","_originalTimeouts","stringify","_timeouts","_options","_maxRetryTime","_fn","_errors","_attempts","_operationTimeout","_operationTimeoutCb","_timeout","_operationStart","_timer","_cachedTimeouts","reset","clearTimeout","currentTime","Date","getTime","unshift","timeout","setTimeout","fn","timeoutOps","cb","try","start","attempts","counts","mainErrorCount","count","isNetworkError","objectToString","errorMessages","Set","authenticatedFetch","cleanUrl","parsePath","repo","parts","checkBranchExists","decodeURIComponent","pathname","split","repoInfoResponse","private","default_branch","apiUrl","then","root","cacheLoader","getElementsByTagName","script","src","preloadLink","rel","as","head","appendChild","async","onerror","e","onload","cachedBundles","cachedPreloads","cachedPrefetches","loader","getCache"],"version":3,"file":"index.fe518e41.js.map"}